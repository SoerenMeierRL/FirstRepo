---
title: "Tutorial: Spatial Regression in R"
subtitle: "Assessing Autocorrelation, Modeling Correlation Structures, and Spatial Autoregressive Models"
author: "Søren Meier"
output:
  html_document:
    toc: true
    toc_float: true
    toc_depth: 3
    theme: cosmo
    highlight: tango
    number_sections: true
editor_options: 
  chunk_output_type: console
  markdown: 
    wrap: 72
bibliography: references.bib
link-citations: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, eval = TRUE, warning = FALSE, message = FALSE, error = TRUE)
```

# Introduction

Welcome to this tutorial on spatial regression! Spatial data often
violates the independence assumption of classical regression because
observations close in space tend to be more similar than those far
apart. This tutorial will guide you through:

-   **Detecting spatial autocorrelation** using Moran's I and
    semivariograms
-   **Fitting basic regression models** and assessing residuals
-   **Incorporating spatial correlation structures** into mixed-effects
    models
-   **Comparing different spatial correlation models**
-   **Evaluating model performance** and reporting findings

We'll use vegetation data from the **sPlotOpen** database, focusing on
European plant communities to understand how environmental factors
influence species richness while accounting for spatial dependencies.

## Learning Objectives

By the end of this tutorial, you will be able to:

1.  Detect violations of independence due to spatial autocorrelation
2.  Assess spatial autocorrelation in model residuals
3.  Fit mixed-effects models with spatial correlation structures
4.  Compare exponential, Gaussian, and spherical correlation structures
5.  Evaluate and select optimal models using AIC and likelihood ratio
    tests
6.  Interpret and report spatial regression results

### Some Information on the Data-set Used

The data you'll be working with in this computer lab comes from a
project called
[*sPlot*](https://www.idiv.de/en/sdiv/working_groups/wg_pool/splot/about_the_project.html),
an initiative of the [German Centre for Integrative Biodiversity
Research (iDiv)](https://www.idiv.de/en/index.html). The complete
*sPlot* database covers a wide range of locations but has uneven
coverage and is not publicly available. However, [@sabatini2021]
addressed these issues by carefully selecting, organising, and obtaining
permission from data owners of 105 different local and regional
data-sets to make some of them open to the public. This led to the
creation of **sPlotOpen**, the largest freely available collection of
plot-based vegetation data. This data-set can be used to study global
plant diversity, assist with remote sensing tasks, or track biodiversity
changes over time.

*sPlotOpen* contains data from around the world. We use a European
subset of the data for this session —sites with over ten species and
sampling areas above 10m^2^. For each site, data includes species
richness (number of different species per plot - `Species_richness`),
location (longitude and latitude - `Longitude`,`Latitude`), country
(`Country`), plot size (in square meters- `Releve_area`), geographical
features (elevation, slope, aspect - `Elevation`, `Aspect`, and
`Slope`), and environmental variables (loading on Principal Component
axes 1 and 2 (`SoilClim_PC1`,`SoilClim_PC2`) based on climate and soil
conditions derived by [@sabatini2021], and the [Environmental
Stratification
Class](https://www.wur.nl/en/research-results/research-institutes/environmental-research/projects/ebone/products/european-environmental-stratification.htm) -
`Env.Strat`; derived by [@metzger2005]).

## Essential Functions Reference

| Task                    | Function                    | Package |
|-------------------------|-----------------------------|---------|
| Linear model            | `lm()`                      | stats   |
| GLS model               | `gls()`                     | nlme    |
| Mixed-effects model     | `lme()`                     | nlme    |
| Moran's I               | `Moran.I()`                 | ape     |
| Moran's I test          | `moran.test()`              | spdep   |
| Moran plot              | `moran.plot()`              | spdep   |
| Neighbors               | `knn2nb()`, `knearneigh()`  | spdep   |
| Weights                 | `nb2listw()`                | spdep   |
| Variogram               | `Variogram()`               | nlme    |
| Variogram               | `variogram()`               | gstat   |
| Exponential correlation | `corExp()`                  | nlme    |
| Gaussian correlation    | `corGaus()`                 | nlme    |
| Spherical correlation   | `corSpher()`                | nlme    |
| Model comparison        | `AIC()`, `anova()`          | stats   |
| Cross-validation        | `train()`, `trainControl()` | caret   |

------------------------------------------------------------------------

# Part 1: Data Preparation and Exploration

## 1.1 Load Required Packages

```{r load-packages}
# Load packages for spatial analysis
library(nlme)     # For mixed-effects models with spatial correlation
library(dplyr)     # For data manipulation
library(ggplot2)     # For visualization
library(sf)     # For simple features (spatial data)
library(spdep)     # For spatial weights and Moran's I
library(gstat)     # For geostatistics and variograms
library(ape)     # For phylogenetic statistics (includes Moran.I)
library(sp)     # For spatial classes
library(lmtest)     # For testing heteroscedasticity
library(caret)     # For k-fold validation
```

**HINT:** Packages needed are: `nlme`, `dplyr`, `ggplot2`, `sf`,
`spdep`, `gstat`, `ape`, `sp`, `lmtest`,`caret`

## 1.2 Load and Explore the Data

```{r load-data}
# Load the sPlot data
sPlot.Data <- read.csv("Splot_SppRichness.csv")

# Explore data structure
str(sPlot.Data)

# View summary statistics
summary(sPlot.Data)

# Check the first few rows
head(sPlot.Data)
```

**TASK:** Fill in functions to read CSV files, examine structure,
summarize, and view the first rows.

## 1.3 Data Cleaning and Standardization

```{r clean-data}
# Remove missing values
sPlot.Data <- na.omit(sPlot.Data)

# Standardize continuous predictors
sPlot.Data$Elevation <- scale(sPlot.Data$Elevation)
sPlot.Data$Slope <- scale(sPlot.Data$Slope)
```

**TASK:** Fill in the function to remove NAs and the function to
standardize variables (z-scores).

## 1.4 Visualize Spatial Distribution

```{r visualize-spatial}
# Create a basic spatial plot of species richness
ggplot(sPlot.Data) +
  geom_point(aes(x = Longitude, y = Latitude, col = Species_richness)) +
  scale_color_viridis_c() +
  theme_minimal() +
  labs(title = "Spatial Distribution of Species Richness",
       x = "Longitude", y = "Latitude")
```

**TASK:** Fill in the geom function for points and the aesthetic
mappings (x, y, color).

```{r visualize-sf}
# Convert to sf object for better spatial visualization
data_sf <- st_as_sf(sPlot.Data, 
                 coords = c("Longitude", "Latitude"), 
                 crs = 4326)

# Plot using geom_sf
ggplot(data_sf) +
  geom_sf(aes(col=Species_richness)) +
  scale_color_viridis_c() +
  theme_minimal() +
  labs(title = "Spatial Distribution of Species Richness")
```

**TASK:** Fill in the function to create sf objects, its arguments
(data, coords, crs), coordinate column names, and the geom for sf
objects.

------------------------------------------------------------------------

# Part 2: Detecting Spatial Autocorrelation

## 2.1 Understanding Spatial Autocorrelation Concepts

**Key Concepts:**

-   **Spatial Autocorrelation**: The correlation of a variable with
    itself through space
    -   *Positive*: Similar values cluster together (high near high, low
        near low)
    -   *Negative*: Dissimilar values are neighbors (high near low)
    -   *Zero*: Random spatial pattern
-   **Moran's I**: Quantifies spatial autocorrelation
    -   Ranges from -1 (dispersion) to +1 (clustering)
    -   Values near 0 suggest randomness
-   **Semivariogram**: Shows how similarity decreases with distance
    -   *Nugget*: Variability at zero distance (measurement error)
    -   *Range*: Distance where correlation diminishes
    -   *Sill*: Plateau indicating total variance

## 2.2 Calculate Moran's I

### Method 1: Using the `ape` package

```{r morans-i-ape}
# Create coordinate matrix
coords <- cbind(sPlot.Data$Longitude, sPlot.Data$Latitude)

# Calculate distance matrix
dist_matrix <- as.matrix(dist(coords))

# Create inverse distance weight matrix
inv_dist_matrix <- 1 / dist_matrix
diag(inv_dist_matrix) <- 0  # Set diagonal to 0

# Calculate Moran's I using ape
library(ape)
moran_result <- Moran.I(x = sPlot.Data$Species_richness,
                      weight = inv_dist_matrix,
                      scaled = TRUE,
                      na.rm = TRUE)

# Display results
print(moran_result)
```

**TASK:** Fill in functions to combine columns, calculate distances, and
compute Moran's I with appropriate arguments.

### Method 2: Using the `spdep` package

```{r morans-i-spdep}
# Create neighbor structure (4 nearest neighbors)
library(spdep)
nb <- knn2nb(knearneigh(coords, k = 4))

# Create spatial weights list
listw <- nb2listw(nb, style = "W")

# Compute Moran's I test
moran.test(sPlot.Data$Species_richness, 
          listw)
```

**TASK:** Fill in functions to create k-nearest neighbors, convert to
neighbor list, create weights, and perform Moran's test.

## 2.3 Visualize Moran's I with a Moran Plot

A Moran scatterplot showing relationship between a variable and the
average value of its neighbors for the same variable It is instructive
to consider each quadrant of the plot. In the upper-right quadrant are
cases where both the value and local average value of the attribute are
higher than the overall average value. Similarly, in the lower-left
quadrant are cases where both the value and local average value of the
attribute are lower than the overall average value. These cases confirm
positive spatial autocorrelation. Cases in the other two quadrants
indicate negative spatial autocorrelation. Depending on which groups are
dominant, there will be an overall tendency towards positive or negative
(or perhaps no) spatial autocorrelation.

```{r moran-plot-manual}
# Create Moran plot data manually (using ape approach)
DataMoranPlot <- data.frame(
  LaggedValues = scale(as.numeric(inv_dist_matrix %*% sPlot.Data$Species_richness)),
  StandardizedValues = scale(sPlot.Data$Species_richness)
)

# Create Moran plot
plot(LaggedValues ~ StandardizedValues, 
     data = DataMoranPlot,
     main = "Moran Plot",
     xlab = "Standardized Values", 
     ylab = "Spatially Lagged Values")
abline(h = 0, v = 0, col = "gray")
abline(lm(LaggedValues ~ StandardizedValues, data = DataMoranPlot), 
       col = "red")
```

**TASK:** Fill in the formula notation for the plot and the function to
fit a linear model.

```{r moran-plot-spdep}
# Moran plot using spdep
moran.plot(x = sPlot.Data$Species_richness, 
          listw,
          main = "Moran Plot of Species Richness")
```

**TASK:** Fill in the function and arguments for creating a Moran plot.

## 2.4 Interpret Moran's I Results

**Your Interpretation:**

-   Moran I Statistic: 0.2298(fill in the value from your output)
-   P-value: \<2.2e-16 (fill in the value)
-   Conclusion: Is there significant spatial autocorrelation? (Yes/No):
    Yes, as the p-value is very low.
-   Type: Is it positive or negative autocorrelation?: Positive
    autocorrelation, as the Moran I value is positive
-   Implication: What does this mean for your analysis?: This means that
    the observations are not independent, and are more clustered than
    expected - the assumption of observation independence is violated,
    which has to be taken into account when modelling the data.

------------------------------------------------------------------------

# Part 3: Basic Linear Regression and Residual Analysis

## 3.1 Fit a Basic Linear Model

```{r fit-lm}
# Fit linear model without spatial components
lm_model <- lm(Species_richness ~ Elevation + Slope + SoilClim_PC1 + SoilClim_PC2,
                  data = sPlot.Data)

# View model summary
summary(lm_model)
```

**TASK:** Fill in the function to fit linear models, the response
variable, and the dataset.

## 3.2 Diagnostic Plots

```{r diagnostic-plots}
# Create diagnostic plots
par(mfrow = c(2, 2))
plot(lm_model)
```

**TASK:** Fill in the function to create diagnostic plots.

## 3.3 Test for Heteroscedasticity

A formal statistical test you can use to determine if heteroscedasticity
is present is the Breusch-Pagan test. The test uses the following null
and alternative hypotheses:

-   Null Hypothesis (H0): Homoscedasticity is present (the residuals are
    distributed with equal variance)
-   Alternative Hypothesis (HA): Heteroscedasticity is present (the
    residuals are not distributed with equal variance)

If the $p$-value of the test is less than some significance level (i.e.
$\alpha$ = 0.05) then we reject the null hypothesis and conclude that
heteroscedasticity is present in the regression model.

```{r test-heteroscedasticity}
# Breusch-Pagan test for heteroscedasticity
library(lmtest)
bptest(lm_model)
```

**TASK:** Fill in the function to perform the Breusch-Pagan test.

## 3.4 Test Residuals for Spatial Autocorrelation

```{r residual-moran}
# Extract residuals
lm_residuals <- resid(lm_model)

# Moran's I on residuals (using ape)
Moran.I(x = lm_residuals,
     weight = inv_dist_matrix,
     scaled = TRUE,
     na.rm = TRUE)

# Moran's I on residuals (using spdep)
moran.test(lm_residuals, 
          listw)
```

**TASK:** Fill in functions to extract residuals and compute Moran's I
on residuals.

**Question:** Do the residuals show spatial autocorrelation? What does
this indicate about the model?: Yes, both Moran I tests show significant
spatial autocorrelation. This indicates that the model is not suited to
model this data, as a simple linear model assumes independence of
observations (which we do not have here)

------------------------------------------------------------------------

# Part 4: Semivariogram Analysis

## 4.1 Fit a GLS Model for Variogram Analysis

```{r fit-gls}
# Fit generalized least squares model
library(nlme)
gls_model <- gls(Species_richness ~ Elevation + Slope + SoilClim_PC1 + SoilClim_PC2,
                   data = sPlot.Data)

# View summary
summary(gls_model)
```

**TASK:** Fill in the function to fit GLS models, the formula, and
dataset.

## 4.2 Calculate and Plot Variogram (Method 1: nlme)

```{r variogram-nlme}
# Estimate variogram from GLS model
Vario1 <- Variogram(gls_model,
                form = ~ Longitude + Latitude,
                robust = TRUE,
                maxDist = 0.5,
                resType = "normalized")

# Plot variogram
plot(Vario1, smooth = TRUE)
```

**TASK:** Fill in the function to calculate variogram, its arguments,
coordinate names, and plotting function.

## 4.3 Calculate and Plot Variogram (Method 2: gstat)

```{r variogram-gstat}
# Add residuals to data
sPlot.Data$residuals <- resid(gls_model)

# Convert to spatial object
library(sp)
sPlot.Spat <- sPlot.Data
coordinates(sPlot.Spat) <- ~ Longitude + Latitude

# Calculate variogram
library(gstat)
# Use Cressie–Hawkins robust estimator (optional, for outlier resistance)
Gstat_variogram <- variogram(residuals ~ 1, 
                             data = sPlot.Spat, 
                             cutoff = 0.5, 
                             width = 0.05,      # adjust lag bin width as needed
                             cressie = TRUE)

# --- Fit a theoretical variogram model ---
# Initial guess for parameters: adjust psill, range, and nugget to your data scale
vgm_model_init <- vgm(psill = var(sPlot.Spat$residuals, na.rm = TRUE) * 0.8,
                      model = "Exp", 
                      range = 0.2, 
                      nugget = var(sPlot.Spat$residuals, na.rm = TRUE) * 0.2)

# Fit model to empirical variogram
Gstat_fit <- fit.variogram(Gstat_variogram, vgm_model_init)

# --- Plot results ---
plot(Gstat_variogram, Gstat_fit, 
     main = "Empirical and Fitted Variogram (gstat)",
     xlab = "Distance", 
     ylab = "Semivariance")
```

**TASK:** Fill in functions to extract residuals, set coordinates (using
the special assignment operator), and calculate variogram.

## 4.4 Interpret the Semivariogram

**Your Interpretation:**

1.  What is the nugget (intercept at distance 0)?: \~0.026
2.  What is the approximate range (distance where it plateaus)?: \~0.25,
    but it does not quite plateau completely
3.  What is the sill (plateau value)?: \~0.035
4.  Does the variogram suggest spatial autocorrelation?: Yes, but the
    nugget and the sill are not very far apart, suggesting that
    correlated observations are not completely different from
    uncorrelated observations
5.  What spatial structure is indicated?: Positive autocorrelation, as
    values close together are more similar than those far apart.

------------------------------------------------------------------------

# Part 5: Mixed-Effects Models with Spatial Correlation Structures

## 5.1 Understanding Spatial Correlation Structures

**Three Common Structures:**

1.  **Exponential** (`corExp`):
    -   Rapid initial decay, long tails
    -   Correlation gradually decreases with distance
    -   Good for moderate to strong short-range autocorrelation
2.  **Gaussian** (`corGaus`):
    -   Smooth, rapid decay
    -   Correlation drops to zero quickly
    -   Good for smooth spatial patterns
3.  **Spherical** (`corSpher`):
    -   Linear increase in semivariance, then levels off
    -   Has a defined range beyond which correlation is zero
    -   Good for processes with finite spatial influence

## 5.2 Fit Model with Exponential Correlation Structure

```{r fit-exponential}
# Fit mixed-effects model with exponential spatial correlation
exponential_model <- lme(Species_richness ~ Elevation + Slope + SoilClim_PC1 + SoilClim_PC2,
                           random = ~ 1 | Country,  # Random intercept by Country
                           correlation = corExp(form = ~ Longitude + Latitude),
                           data = sPlot.Data)

# View summary
summary(exponential_model)

# Compare to basic GLS
anova(exponential_model, gls_model)
```

**TASK:** Fill in the function for mixed-effects models, response
variable, random effect grouping variable, correlation structure
function, coordinate formula, dataset, and comparison function.

## 5.3 Fit Model with Gaussian Correlation Structure

```{r fit-gaussian}
# Update with Gaussian correlation structure
gaussian_model <- update(exponential_model, 
                        correlation = corGaus(form = ~ Longitude + Latitude))

# View summary
summary(gaussian_model)

# Compare to GLS
anova(gaussian_model, gls_model)
```

**TASK:** Fill in the function to update models and the Gaussian
correlation structure function.

## 5.4 Fit Model with Spherical Correlation Structure

```{r fit-spherical}
# Update with Spherical correlation structure
spherical_model <- update(exponential_model, 
                          correlation = corSpher(form = ~ Longitude + Latitude))

# View summary
summary(spherical_model)

# Compare to GLS
anova(spherical_model, gls_model)
```

**TASK:** Fill in the spherical correlation function and coordinate
formula.

------------------------------------------------------------------------

# Part 6: Model Comparison and Selection

## 6.1 Compare Models Using AIC

```{r compare-aic}
# Compare all models using AIC
AIC(gls_model, exponential_model, gaussian_model, spherical_model)
BIC(gls_model, exponential_model, gaussian_model, spherical_model)
```

**TASK:** Fill in the function to calculate AIC and the four model
objects to compare.

## 6.2 Likelihood Ratio Tests

```{r compare-lrt}
# Likelihood ratio test comparing spatial models
lrtest(exponential_model, gaussian_model, spherical_model)
lrtest(gls_model)
```

**TASK:** Fill in the function to perform ANOVA comparison of multiple
models.

## 6.3 Summarize Model Comparison

Create a table summarizing the model comparison:

| Model            | df  | AIC     | BIC     | logLik | Best? |
|------------------|-----|---------|---------|--------|-------|
| GLS (no spatial) | 6   | -284.59 | -256.00 | 148.30 | No    |
| Exponential      | 8   | -355.59 | -317.48 | 185.80 | Yes   |
| Gaussian         | 8   | -355.44 | -317.32 | 185.72 | No    |
| Spherical        | 8   | -354.59 | -317.47 | 185.29 | No    |

**Question:** Which model has the lowest AIC? Is this model
significantly better than the others?: The exponential correlation
structure model has the lowest AIC, but it is not significantly better
than the two other spatial correlation structure models (AIC difference
is under 2).

------------------------------------------------------------------------

# Part 7: Model Refinement and Validation

## 7.1 Fine-Tune the Best Model

```{r tune-model}
# Add nugget parameter to the best model
spatial_model_tuned <- update(exponential_model,
                             correlation = corExp(form = ~ Longitude + Latitude, 
                                                 nugget = TRUE))

# View summary
summary(spatial_model_tuned)

# Check variogram of tuned model
Vario_tuned <- Variogram(spatial_model_tuned,
                         form = ~ Longitude + Latitude,
                         robust = TRUE,
                         maxDist = 1,
                         resType = "normalized")
plot(Vario_tuned, smooth = TRUE)
```

**TASK:** Fill in the function to update models and the nugget argument.

## 7.2 Cross-Validation

```{r cross-validation}
# Create folds for 5-fold cross-validation
set.seed(123)
Folds <- createFolds(sPlot.Data$X, k = 5)


# Perform cross-validation
CV <- sapply(1:5, function(i) {
  Train <- update(spatial_model_tuned, data = sPlot.Data[Folds[[i]], ])
  Test <- predict(Train, sPlot.Data[-Folds[[i]], ])
  Test - sPlot.Data$Species_richness[-Folds[[i]]]
})

# Test if average deviation is different from 0
t.test(unlist(CV))

# Calculate RMSE
RMSE <- sqrt(mean(unlist(CV)^2, na.rm = TRUE))
print(paste("RMSE:", round(RMSE, 2)))

# Calculate MAE
MAE <- mean(abs(unlist(CV)), na.rm = TRUE)
print(paste("MAE:", round(MAE, 2)))
```

**TASK:** Fill in functions for getting dimensions, updating models,
making predictions, and performing t-test.

## **REMEMBER**: Root Mean Squared Error (RMSE; i.e., the square-Root of the the mean of the squared residuals) and Mean Absolute Error (MAE; i.e., the mean of the absiklute residuals) are metrics used to evaluate a Regression Model. These metrics tell us how accurate our predictions are and, what is the amount of deviation from the actual values.

# Part 8: Model Visualization and Interpretation

## 8.1 Observed vs. Predicted Plot

```{r obs-pred-plot}
# Get predicted values
predicted_values <- predict(exponential_model, sPlot.Data)

# Create plot
ggplot(sPlot.Data, aes(x = Species_richness, y = predicted_values)) +
  geom_point(alpha = 0.5) +
  geom_abline(slope = 1, intercept = 0, color = "red", linewidth = 1) +
  theme_minimal() +
  labs(title = "Observed vs. Predicted Species Richness",
       x = "Observed Species Richness",
       y = "Predicted Species Richness")
```

**TASK:** Fill in the predict function, dataset, data frame for ggplot,
x and y aesthetics, and geom for points.

## 8.2 Spatial Map of Residuals

```{r residual-map}
# Add residuals to spatial data
data_sf$residuals <- resid(exponential_model)

# Plot residuals spatially
ggplot(data_sf) +
  geom_sf(aes(col=residuals)) +
  scale_color_gradient2(low = "blue", mid = "white", high = "red", 
                       midpoint = 0) +
  theme_minimal() +
  labs(title = "Spatial Pattern of Model Residuals",
       color = "Residuals")
```

**TASK:** Fill in functions to extract residuals and create sf geometry
plot.

## 8.3 Check Residual Autocorrelation

```{r check-final-residuals}
# Extract residuals from spatial model
spatial_residuals <- residuals(exponential_model, type = "normalized")

# Moran's I on spatial model residuals
Moran.I(x = spatial_residuals,
        weight = inv_dist_matrix,
        scaled = TRUE,
        na.rm = TRUE)

# Compare to original residuals
cat("\nMoran's I for LM residuals:\n")
Moran.I(x = lm_residuals, weight = inv_dist_matrix, 
        scaled = TRUE, na.rm = TRUE)

summary(spatial_model_tuned)
```

**Question:** Has the spatial correlation in residuals been reduced? By
how much?: Yes, from 0.12 to 0.057, roughly halfing the amount of
spatial autocorrelation.

------------------------------------------------------------------------

# Part 9: Reporting Results

## 9.1 Model Summary Table

**Fixed Effects:**

| Predictor    | Estimate | Std. Error | t-value | p-value | Interpretation            |
|--------------|----------|------------|---------|---------|---------------------------|
| Intercept    | 1.3332   | 0.0319     | 41.82   | 0.0000  | Highly significant effect |
| Elevation    | -0.0549  | 0.0139     | -3.93   | 0.0001  | Highly significant effect |
| Slope        | 0.0034   | 0.0074     | 0.46    | 0.6479  | No significant effect     |
| SoilClim_PC1 | -0.0229  | 0.0150     | -1.53   | 0.1266  | No significant effect     |
| SoilClim_PC2 | 0.0078   | 0.0076     | 1.02    | 0.3084  | No significant effect     |

## 9.2 Random Effects and Spatial Structure

**Random Effects:** - Country random intercept SD: 0.086 ***- Residual
SD: 0.19***

**Spatial Correlation Structure:** - Type: Exponential
(Exponential/Gaussian/Spherical) - Range parameter: 0.21 ***- Nugget:
0.73***

## 9.3 Model Performance

-   AIC: -398.30
-   BIC: -355.42
-   RMSE: 0.2
-   MAE: 0.16
-   Reduction in Moran's I: 0.12 to 0.057

## 9.4 Write Your Interpretation

*Write a paragraph summarizing your findings:*

1.  Which environmental variables significantly affect species
    richness?: Only elevation, as this is the only variable with a
    significant p-value.
2.  What is the direction and magnitude of these effects?: The direction
    is negative, and the magnitude is 0.055, which means an increase of
    elevation decreases the species richness.
3.  How much spatial autocorrelation was present initially?: The Moran I
    test of the initial data gave a value of 0.12, which is a fairly
    small value.
4.  How well did the spatial model address the autocorrelation?: The
    amount of spatial autocorrelation was halved, which means that the
    spatial model eliminates some of the autocorrelation, but not
    completely.
5.  What are the practical implications of your findings? Spatial
    autocorrelation is a problem for analysing these species richness
    data, as similar values closter together in space. This has to be
    taken care of in modelling, which we have shown can reduce some of
    the problem with autocorrelation.

# Challenge Exercises

## Challenge 1: Alternative Predictors

Reload the full dataset (`Splot_SppRichness_AllVars.csv`) and include
additional environmental variables. Does this change your spatial
correlation structure selection?

## Challenge 2: Directional Autocorrelation

Investigate whether spatial autocorrelation is the same in all
directions (isotropic) or varies by direction (anisotropic). Use
directional variograms.

## Challenge 3: Local vs. Global Models

Compare your global spatial model with local regression techniques
(e.g., Geographically Weighted Regression). Which performs better?

## Challenge 4: Prediction Mapping

Create a prediction map showing estimated species richness across Europe
based on your spatial model.

------------------------------------------------------------------------

# References
